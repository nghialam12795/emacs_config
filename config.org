#+AUTHOR: Nghia Lam
#+TITLE: PENMACS Configuration

[[./res/screenshots/workspace.png]]

* Table of Content                                                      :TOC:
- [[#about][About]]
- [[#emacs-startup][Emacs Startup]]
  - [[#system-information][System Information]]
  - [[#personal-information][Personal Information]]
  - [[#setting-default][Setting Default]]
  - [[#file-management][File Management]]
- [[#package-initialize][Package Initialize]]
- [[#advanced-config][Advanced Config]]
  - [[#autorevert][Autorevert]]
  - [[#calendar][Calendar]]
  - [[#dired][Dired]]
  - [[#fast-scroll][Fast Scroll]]
  - [[#editor-support][Editor Support]]
  - [[#eww][EWW]]
  - [[#lsp-mode][LSP Mode]]
  - [[#git][Git]]
  - [[#ibuffer][Ibuffer]]
  - [[#ivy][Ivy]]
  - [[#hydra][Hydra]]
  - [[#paren][Paren]]
  - [[#pdf-reader][PDF Reader]]
  - [[#projectile][Projectile]]
  - [[#swiper][Swiper]]
  - [[#terminal][Terminal]]
  - [[#utilities][Utilities]]
  - [[#weather-forecast][Weather Forecast]]
  - [[#whitespace][Whitespace]]
- [[#language-support][Language Support]]
  - [[#c][C++]]
  - [[#cmake][CMake]]
  - [[#css][CSS]]
  - [[#elisp][Elisp]]
  - [[#json][Json]]
  - [[#latex][Latex]]
  - [[#markdown][Markdown]]
  - [[#python][Python]]
- [[#user-interface][User Interface]]
- [[#org-mode][Org Mode]]

* About
This is my configuration for the GNUs Emacs, which I call it PENMACS (Penguin x Emacs). WARNING: It's really long.
This configuration is based on my habit, which may not be suitable for some people. This config helps me in daily life works and personal notes.

For Emacs beginner, I'd recommend taking a look at [[https://github.com/hlissner/doom-emacs][doom-emacs]] or [[https://github.com/syl20bnr/spacemacs][Spacemacs]] (Vim Users).

My configuration is mostly inspired from:
- [[https://github.com/rememberYou/.emacs.d][Terencio Agozzino]]
- [[https://github.com/sachac/.emacs.d][Sacha Chua]]

You guys should check them out, they are both really talent. Especially, Sacha has a [[https://sachachua.com/blog/][blog]] about boosting Emacs in life.

* Emacs Startup
** System Information
Here I setup some info for my PENMACS. As my job requires me to work on all OS, you will see a lot of times I need to config for each of them differently.

#+begin_src emacs-lisp :tangle yes
(defvar pemacs/version
  "0.1.1"
  "Penguin Emacs version.")
(defconst my-homepage
  "https://github.com/nghialam12795"
  "My personal Github page.")
(defconst sys/win32
  (eq system-type 'windows-nt)
  "Are we using a Window OS?")
(defconst sys/linux
  (eq system-type 'gnu/linux)
  "Are we using a GNU/Linux OS?")
(defconst sys/macos
  (eq system-type 'darwin)
  "Are we using a Mac OS?")
(defconst emacs/>=26p
  (>= emacs-major-version 26)
  "Emacs is 26 or above.")
#+end_src

** Personal Information
#+begin_src emacs-lisp :tangle yes
(setq-default user-full-name "Nghia Lam"
              user-mail-address "nghialam12795@gmail.com")
#+end_src

** Setting Default
#+begin_src emacs-lisp :tangle yes
(advice-add #'display-startup-echo-area-message :override #'ignore)
(setq-default
  ad-redefinition-action 'accept                   ; Silence warnings for redefinition
  auto-window-vscroll nil                          ; Lighten vertical scroll
  bidi-display-reordering 'left-to-right           ; For optimization
  bidi-paragraph-direction 'left-to-right
  blink-matching-paren nil                         ; Dont blink mathcing paren
  confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
  cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
  compilation-always-kill t                        ; Kill compilation process before starting another
  compilation-ask-about-save nil                   ; Save all buffers on `compile'
  compilation-scroll-output t
  delete-by-moving-to-trash t                      ; Delete files to trash
  display-time-default-load-average nil            ; Don't display load average
  display-time-format "%H:%M"                      ; Format the time string
  fill-column 80                                   ; Set width for automatic line breaks
  fringe-indicator-alist
    (delq (assq 'continuation
                fringe-indicator-alist)
          fringe-indicator-alist)                  ; Remove continuation arrow on the right frame
  help-window-select t                             ; Focus new help windows when opened
  indent-tabs-mode nil                             ; Stop using tabs to indent
  idle-update-delay 1                              ; Slow down update ui a bit
  inhibit-default-init t                           ; Default initialization
  inhibit-startup-message t                        ; Do not show anythings unnecessary
  initial-scratch-message nil                      ; Empty the initial *scratch* buffer
  inhibit-startup-echo-area-message user-full-name ; Show User name
  initial-major-mode 'fundamental-mode
  jit-lock-defer-time nil                          ; Font lock optimization
  jit-lock-stealth-nice 0.1
  jit-lock-stealth-time 0.2
  jit-lock-stealth-verbose nil
  ;; mode-line-format nil                             ; Disable mode line format when startup
  mouse-yank-at-point t                            ; Yank at point rather than pointer
  ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
  recenter-positions '(5 top bottom)               ; Set re-centering positions
  ffap-machine-p-known 'reject                     ; Dont ping thing that look like domain
  frame-inhibit-implied-resize t                   ; Frame optimization
  highlight-nonselected-windows nil                ; Remove highlight on nonselected windows
  hscroll-margin 2                                 ; Horizontal scroll
  hscroll-step 1                                   ; Horizontal step
  fast-but-imprecise-scrolling t                   ; Fast scrolling
  recenter-positions '(top middle bottom)          ; Setup recenter
  scroll-conservatively most-positive-fixnum       ; Always scroll by one line
  scroll-margin 0                                  ; Add a margin when scrolling vertically
  scroll-preserve-screen-position t                ; Reduce cursor lag a bit
  mouse-wheel-scroll-amount '(5 ((shift) . 2))     ; Shift Mouse wheel
  mouse-wheel-progressive-speed nil                ; don't accelerate scrolling
  select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
  sentence-end-double-space nil                    ; End a sentence after a dot and a space
  show-help-function nil                           ; Disable help messages
  show-trailing-whitespace nil                     ; Display trailing whitespaces
  split-height-threshold nil                       ; Disable vertical window splitting
  split-width-threshold nil                        ; Disable horizontal window splitting
  use-file-dialog nil                              ; Disable use file dialog
  use-dialog-box nil                               ; Disable use dialog box
  uniquify-buffer-name-style 'forward              ; Uniquify buffer names
  visible-bell 1                                   ; Turn off annoying sound
  window-combination-resize t                      ; Resize windows proportionally
  x-stretch-cursor t)                              ; Stretch cursor to the glyph width
(cd "~/")                                          ; Move to the user directory
(delete-selection-mode 1)                          ; Replace region when inserting text
(display-time-mode 1)                              ; Enable time in the mode-line
(fringe-mode 0)                                    ; Disable fringes
(fset 'yes-or-no-p 'y-or-n-p)                      ; Replace yes/no prompts with y/n
(global-subword-mode 1)                            ; Iterate through CamelCase words
(mouse-avoidance-mode 'banish)                     ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)               ; Enable downcase-region
(put 'upcase-region 'disabled nil)                 ; Enable upcase-region
(prefer-coding-system 'utf-8-unix)
(set-locale-environment "en_US.UTF-8")
(set-default-coding-systems 'utf-8-unix)
(set-selection-coding-system 'utf-8-unix)
(set-buffer-file-coding-system 'utf-8-unix)
(set-clipboard-coding-system 'utf-8)               ; included by set-selection-coding-system
(set-keyboard-coding-system 'utf-8)                ; configured by prefer-coding-system
(set-terminal-coding-system 'utf-8)                ; configured by prefer-coding-system
(setq buffer-file-coding-system 'utf-8)            ; utf-8-unix
(setq save-buffer-coding-system 'utf-8-unix)       ; nil
(setq process-coding-system-alist
      (cons '("grep" utf-8 . utf-8) process-coding-system-alist))
(unless sys/macos (setq command-line-ns-option-alist nil))
(unless sys/linux (setq command-line-x-option-alist nil))
(toggle-frame-maximized)                           ; Toggle maximized

#+end_src

Some specific OS tweak:
#+begin_src emacs-lisp :tangle yes
(when sys/macos
  (setq mac-redisplay-dont-reset-vscroll t
        mac-mouse-wheel-smooth-scroll nil
        ns-pop-up-frames nil
        initial-frame-alist (append '((ns-transparent-titlebar . t)
                                      (ns-appearance . dark)
                                     )
                            )
  )
  (and (or (daemonp)
           (display-graphic-p))
       (require 'ns-auto-titlebar nil t)
       (ns-auto-titlebar-mode +1)
  )
  (setq mac-command-modifier 'meta) ; make cmd key do Meta
  (setq mac-option-modifier 'super) ; make opt key do Super
  (setq mac-control-modifier 'control) ; make Control key do Control
  (setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
)
#+end_src
#+begin_src emacs-lisp :tangle yes
(when sys/win32
  (set-selection-coding-system 'utf-16-le)) ; For fixing broken symbol render in Windows. Any ideas why it happened?
#+end_src

Remove unnecessary error warnings
#+begin_src emacs-lisp :tangle yes
(defun penguin-command-error-function (data context caller)
  "Ignore the `buffer-read-only',`beginning-of-buffer',`end-of-buffer' signals.
Then pass DATA, CONTEXT & CALLER to the default handler."
  (when (not (memq (car data) '(buffer-read-only
                                beginning-of-buffer
                                end-of-buffer)))
    (command-error-default-function data context caller)))

(setq command-error-function #'penguin-command-error-function)
#+end_src

Other personal settings will be written to user.el
#+begin_src emacs-lisp :tangle yes
(setq custom-file (expand-file-name "~/.emacs.d/.local/user.el" user-emacs-directory))
;; If user.el is not there, duplicate the template for it
(let ((user-template-file
       (expand-file-name "user_template.el" user-emacs-directory)))
  (if (and (file-exists-p user-template-file)
           (not (file-exists-p custom-file)))
      (copy-file user-template-file custom-file)))

(if (file-exists-p custom-file)
    (load custom-file))
#+end_src

** File Management
I'd like to keep my folder as clean as possible. So I decide to move the auto-generated files around.

*** Folder structure
#+begin_src emacs-lisp :tangle yes
(defvar pemacs-dir (file-truename user-emacs-directory)
  "The path to this emacs.d directory.")
(defvar pcore-dir (concat pemacs-dir "core/")
  "Where essential files are stored.")
(defvar pmodules-dir (concat pemacs-dir "modules/")
  "Where configuration modules are stored.")
(defvar plocal-dir (concat pemacs-dir ".local/")
  "Root directory for local Emacs files.
Use this as permanent storage for files that are safe to share
across systems (if this config is symlinked across several computers).")
(defvar petc-dir (concat plocal-dir "etc/")
  "Directory for non-volatile storage.
Use this for files that don't change much, like servers binaries, external
dependencies or long-term shared data.")
(defvar pcache-dir (concat plocal-dir "cache/")
  "Directory for volatile storage.
Use this for files that change often, like cache files.")
#+end_src

*** Backup Location
#+begin_src emacs-lisp :tangle yes
(defun penguin_backup_file_name (fpath)
  "Backup files in a designated FPATH."
  (let* ((backupRootDir (concat plocal-dir "_backup"))
         (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path, for example, “C:”
         (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") )))
         (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
         backupFilePath))
(setq make-backup-file-name-function 'penguin_backup_file_name)
#+end_src

*** Others
#+begin_src emacs-lisp :tangle yes
(setq-default abbrev-file-name             (concat plocal-dir "abbrev.el")
              auto-save-list-file-name     (concat pcache-dir "autosave")
              pcache-directory             (concat pcache-dir "pcache/")
              recentf-save-file            (concat plocal-dir "recentf")
              mc/list-file                 (concat petc-dir "mc-lists.el")
              server-auth-dir              (concat pcache-dir "server/")
              shared-game-score-directory  (concat petc-dir "shared-game-score/")
              tramp-auto-save-directory    (concat pcache-dir "tramp-auto-save/")
              tramp-backup-directory-alist backup-directory-alist
              tramp-persistency-file-name  (concat pcache-dir "tramp-persistency.el")
              url-cache-directory          (concat pcache-dir "url/")
              url-configuration-directory  (concat petc-dir "url/")
              package-user-dir             (concat plocal-dir "packages"))
#+end_src
* Package Initialize
In order to install packages, use-package is a no-brainer for you.
But first, we need to add some sources
#+begin_src emacs-lisp :tangle yes
(package-initialize)
(setq package-archives '(("gnu"   . "http://elpa.gnu.org/packages/")
                         ("melpa" . "http://melpa.org/packages/")
                         ("org" . "http://orgmode.org/elpa/")))
#+end_src

Here goes our monster =use-package=
#+begin_src emacs-lisp :tangle yes
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-and-compile
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally t)
  (setq use-package-enable-imenu-support t))

(eval-when-compile
  (require 'use-package))

(use-package gcmh
  :ensure t
  :init
  (gcmh-mode 1))

(use-package quelpa
  :ensure t
  :defer t
  :custom
  (quelpa-update-melpa-p nil "Don't update the MELPA git repo."))

(use-package quelpa-use-package :ensure t)

;; Package Manager
(use-package paradox
  :custom
  (paradox-column-width-package 27)
  (paradox-column-width-version 13)
  (paradox-execute-asynchronously t)
  (paradox-github-token t)
  (paradox-hide-wiki-packages t)
  :config
  (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+end_src

* Advanced Config
In editor war, the winner is not Emacs or Vim, it's your configuration with these two.
Now let's turn this Emacs into a real monster.

** Autorevert
Automatically reload files was modified by external program.
#+begin_src emacs-lisp :tangle yes
(use-package autorevert
  :ensure nil
  :diminish
  :hook (after-init . global-auto-revert-mode))
#+end_src

** Calendar
I usually let emacs fullscreen and open all the times, so I need to see the calendar inside Emacs.
#+begin_src emacs-lisp :tangle yes
(use-package calfw
  :commands cfw:open-calendar-buffer
  :bind ("<C-f11>" . open-calendar)
  :init
  (use-package calfw-org
    :commands (cfw:open-org-calendar cfw:org-create-source))

  (use-package calfw-ical
    :commands (cfw:open-ical-calendar cfw:ical-create-source))

  (defun open-calendar ()
    "Open calendar."
    (interactive)
    (unless (ignore-errors
              (cfw:open-calendar-buffer
               :contents-sources
               (list
                (when org-agenda-files
                  (cfw:org-create-source "YellowGreen"))
                (when (bound-and-true-p centaur-ical)
                  (cfw:ical-create-source "gcal" centaur-ical "IndianRed")))))
      (cfw:open-calendar-buffer))))
#+end_src

** Dired
Emacs is also a file explorer alternative.
#+begin_src emacs-lisp :tangle yes
(use-package dired
  :ensure nil
  :preface
  (defun penguin/dired-directories-first ()
    "Sort dired listings with directories first before adding marks."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2)
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))
  :hook
  (dired-mode . dired-hide-details-mode)
  :custom
  (dired-auto-revert-buffer t)
  (dired-dwim-target t)
  (dired-hide-details-hide-symlink-targets nil)
  (dired-listing-switches "-alh")
  (dired-ls-F-marks-symlinks nil)
  (dired-recursive-copies 'always)
  :config
  (advice-add 'dired-readin :after #'penguin/dired-directories-first))
(use-package dired-subtree
  :bind (:map dired-mode-map
              ("<backtab>" . dired-subtree-cycle)
              ("<tab>" . dired-subtree-toggle)))
(use-package dired-git-info
  :ensure t
  :after dired
  :config
  (setq dgi-commit-message-format "%h\t%s\t%cr")
  :bind (:map dired-mode-map
              (")" . dired-git-info-mode)))
#+end_src

** Fast Scroll
Scrolling through a large buffer cause my MacOS laggy. This package can prevent that.
#+begin_src emacs-lisp :tangle yes
(use-package fast-scroll
  :ensure t
  :diminish fast-scroll-mode
  :config
  (fast-scroll-config)
  (fast-scroll-mode 1))
#+end_src

** Editor Support
*** Ace-jump
Jumping around the workspace for quickly editing is a big plus. Say NO to mouse.
#+begin_src emacs-lisp :tangle yes
(require 'ace-jump-mode)
(eval-after-load "ace-jump-mode" '(ace-jump-mode-enable-mark-sync))
(define-key global-map (kbd "C-j") 'ace-jump-mode)
(define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
#+end_src

*** Autocomplete
=company= is a powerful package provide an auto-completion at point, which display a small pop-in containing the candidate.
I also =company-box= that allow a company front-end with more compact UI.
#+begin_src emacs-lisp :tangle yes
(use-package company
  :diminish
  :defines (company-dabbrev-ignore-case company-dabbrev-downcase)
  :commands company-abort
  :bind (("M-/" . company-complete)
         ("<backtab>" . company-yasnippet)
         :map company-active-map
         ("C-p" . company-select-previous)
         ("C-n" . company-select-next)
         ("<tab>" . company-complete-common-or-cycle)
         ("<backtab>" . my-company-yasnippet)
         ;; ("C-c C-y" . my-company-yasnippet)
         :map company-search-map
         ("C-p" . company-select-previous)
         ("C-n" . company-select-next))
  :hook (after-init . global-company-mode)
  :init
  (defun my-company-yasnippet ()
    "Hide the current completeions and show snippets."
    (interactive)
    (company-abort)
    (call-interactively 'company-yasnippet))
  :config
  (setq company-tooltip-align-annotations t
        company-tooltip-limit 12
        company-idle-delay 0
        company-echo-delay (if (display-graphic-p) nil 0)
        company-minimum-prefix-length 2
        company-require-match nil
        company-dabbrev-ignore-case nil
        company-dabbrev-downcase nil)

  ;; Better sorting and filtering
  (use-package company-prescient
    :init (company-prescient-mode 1))

  ;; Icons and quickhelp
  (when emacs/>=26p
    (use-package company-box
      :diminish
      :hook (company-mode . company-box-mode)
      :init (setq company-box-backends-colors nil
                  company-box-show-single-candidate t
                  company-box-max-candidates 50
                  company-box-doc-delay 0.5)
      :config
      (with-no-warnings
        ;; Highlight `company-common'
        (defun my-company-box--make-line (candidate)
          (-let* (((candidate annotation len-c len-a backend) candidate)
                  (color (company-box--get-color backend))
                  ((c-color a-color i-color s-color) (company-box--resolve-colors color))
                  (icon-string (and company-box--with-icons-p (company-box--add-icon candidate)))
                  (candidate-string (concat (propertize (or company-common "") 'face 'company-tooltip-common)
                                            (substring (propertize candidate 'face 'company-box-candidate)
                                                       (length company-common) nil)))
                  (align-string (when annotation
                                  (concat " " (and company-tooltip-align-annotations
                                                   (propertize " " 'display `(space :align-to (- right-fringe ,(or len-a 0) 1)))))))
                  (space company-box--space)
                  (icon-p company-box-enable-icon)
                  (annotation-string (and annotation (propertize annotation 'face 'company-box-annotation)))
                  (line (concat (unless (or (and (= space 2) icon-p) (= space 0))
                                  (propertize " " 'display `(space :width ,(if (or (= space 1) (not icon-p)) 1 0.75))))
                                (company-box--apply-color icon-string i-color)
                                (company-box--apply-color candidate-string c-color)
                                align-string
                                (company-box--apply-color annotation-string a-color)))
                  (len (length line)))
            (add-text-properties 0 len (list 'company-box--len (+ len-c len-a)
                                             'company-box--color s-color)
                                 line)
            line))
        (advice-add #'company-box--make-line :override #'my-company-box--make-line)

        ;; Prettify icons
        (defun my-company-box-icons--elisp (candidate)
          (when (derived-mode-p 'emacs-lisp-mode)
            (let ((sym (intern candidate)))
              (cond ((fboundp sym) 'Function)
                    ((featurep sym) 'Module)
                    ((facep sym) 'Color)
                    ((boundp sym) 'Variable)
                    ((symbolp sym) 'Text)
                    (t . nil)))))
        (advice-add #'company-box-icons--elisp :override #'my-company-box-icons--elisp))

      (when (and (display-graphic-p)
                 (require 'all-the-icons nil t))
        (declare-function all-the-icons-faicon 'all-the-icons)
        (declare-function all-the-icons-material 'all-the-icons)
        (declare-function all-the-icons-octicon 'all-the-icons)
        (setq company-box-icons-all-the-icons
              `((Unknown . ,(all-the-icons-material "find_in_page" :height 0.85 :v-adjust -0.2))
                (Text . ,(all-the-icons-faicon "text-width" :height 0.8 :v-adjust -0.05))
                (Method . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.05 :face 'all-the-icons-purple))
                (Function . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.05 :face 'all-the-icons-purple))
                (Constructor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.05 :face 'all-the-icons-purple))
                (Field . ,(all-the-icons-octicon "tag" :height 0.8 :v-adjust 0 :face 'all-the-icons-lblue))
                (Variable . ,(all-the-icons-octicon "tag" :height 0.8 :v-adjust 0 :face 'all-the-icons-lblue))
                (Class . ,(all-the-icons-material "settings_input_component" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-orange))
                (Interface . ,(all-the-icons-material "share" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-lblue))
                (Module . ,(all-the-icons-material "view_module" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-lblue))
                (Property . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.05))
                (Unit . ,(all-the-icons-material "settings_system_daydream" :height 0.85 :v-adjust -0.2))
                (Value . ,(all-the-icons-material "format_align_right" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-lblue))
                (Enum . ,(all-the-icons-material "storage" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-orange))
                (Keyword . ,(all-the-icons-material "filter_center_focus" :height 0.85 :v-adjust -0.2))
                (Snippet . ,(all-the-icons-material "format_align_center" :height 0.85 :v-adjust -0.2))
                (Color . ,(all-the-icons-material "palette" :height 0.85 :v-adjust -0.2))
                (File . ,(all-the-icons-faicon "file-o" :height 0.85 :v-adjust -0.05))
                (Reference . ,(all-the-icons-material "collections_bookmark" :height 0.85 :v-adjust -0.2))
                (Folder . ,(all-the-icons-faicon "folder-open" :height 0.85 :v-adjust -0.05))
                (EnumMember . ,(all-the-icons-material "format_align_right" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-lblue))
                (Constant . ,(all-the-icons-faicon "square-o" :height 0.85 :v-adjust -0.05))
                (Struct . ,(all-the-icons-material "settings_input_component" :height 0.85 :v-adjust -0.2 :face 'all-the-icons-orange))
                (Event . ,(all-the-icons-octicon "zap" :height 0.8 :v-adjust 0 :face 'all-the-icons-orange))
                (Operator . ,(all-the-icons-material "control_point" :height 0.85 :v-adjust -0.2))
                (TypeParameter . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.05))
                (Template . ,(all-the-icons-material "format_align_center" :height 0.85 :v-adjust -0.2)))
              company-box-icons-alist 'company-box-icons-all-the-icons))))

  ;; Popup documentation for completion candidates
  (when (and (not emacs/>=26p) (display-graphic-p))
    (use-package company-quickhelp
      :defines company-quickhelp-delay
      :bind (:map company-active-map
             ([remap company-show-doc-buffer] . company-quickhelp-manual-begin))
      :hook (global-company-mode . company-quickhelp-mode)
      :init (setq company-quickhelp-delay 0.5))))

#+end_src

*** Delsel
=C-c C-g= will always quit the minibuffer.
#+begin_src emacs-lisp :tangle yes
(use-package delsel
  :bind
  (:map mode-specific-map
        ("C-g" . minibuffer-keyboard-quit)))
#+end_src

*** Docsets
I use [[https://github.com/chubin/cheat.sh][cheat.sh]] as my quick cheatsheets and =counsel-dash= to browse the complete dash docsets.
You'd need to install the docsets you want with =dash-doc-install-docsets= command. For me, I work mostly with *C++* so I just need it's docsets.
#+begin_src emacs-lisp :tangle yes
(use-package helm-dash)
(use-package counsel-dash)
(add-hook 'emacs-lisp-mode-hook '(lambda ()
                                   (setq-local counsel-dash-docsets '("Emacs Lisp"))
                                   (setq helm-current-buffer (current-buffer))))
(add-hook 'c-mode-common-hook '(lambda ()
                                 (setq-local counsel-dash-docsets '("C++"))
                                 (setq helm-current-buffer (current-buffer))))

(global-set-key (kbd "M-h")  'counsel-dash-at-point)

(setq dash-docs-docsets-path "~/.emacs.d/.docsets")
;; (setq dash-docs-browser-func 'eww-browse-url)
(setq counsel-dash-min-length 3)
(setq counsel-dash-candidate-format "%d %n (%t)")
(setq counsel-dash-enable-debugging nil)
(setq counsel-dash-ignored-docsets nil)
#+end_src

*** Linter
*** Move Text
Not the best option for hotkey right now ...
#+begin_src emacs-lisp :tangle yes
;; `Move text'
(use-package move-text
  :bind (("M-p" . move-text-up)
         ("M-n" . move-text-down))
  :config (move-text-default-bindings))
#+end_src

*** Multiple Cursors
A really great package for editing. I use it all the time for editing multiple line or replace a symbol.
#+begin_src emacs-lisp :tangle yes
(use-package multiple-cursors)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+end_src

*** Scrolling with keys
Let's make scrolling right.
#+begin_src emacs-lisp :tangle yes
(defun push-mark-no-activate ()
  "Pushes `point` to `mark-ring' and does not activate the region.
Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)) ; removed the message, visible-mark takes care of this

(defun penguin/scroll-down-with-mark ()
  "Like `scroll-down-command`, but push a mark if this is not a repeat invocation."
  (interactive)
  (unless (equal last-command 'penguin/scroll-down-with-mark)
    (push-mark-no-activate))
  (scroll-down-command))

(defun penguin/scroll-up-with-mark ()
  "Like `scroll-up-command`, but push a mark if this is not a repeat invocation."
  (interactive)
  (unless (equal last-command 'penguin/scroll-up-with-mark)
    (push-mark-no-activate))
  (scroll-up-command))

(global-set-key (kbd "C-v") 'penguin/scroll-up-with-mark)
(global-set-key (kbd "M-v") 'penguin/scroll-down-with-mark)
#+end_src

*** Smart Comment
#+begin_src emacs-lisp :tangle yes
(use-package smart-comment
  :bind ("M-;" . smart-comment))
#+end_src

*** Snippet
A good IDE always come with a good snippet configuration.
#+begin_src emacs-lisp :tangle yes
(use-package yasnippet-snippets
  :ensure t
  :after yasnippet
  :config (yasnippet-snippets-initialize))

(use-package yasnippet
  :delight yas-minor-mode " υ"
  :hook (yas-minor-mode . penguin/disable-yas-if-no-snippets)
  :config (yas-global-mode)
  :preface
  (defun penguin/disable-yas-if-no-snippets ()
    (when (and yas-minor-mode (null (yas--get-snippet-tables)))
      (yas-minor-mode -1))))

(use-package ivy-yasnippet :after yasnippet)
(use-package react-snippets :after yasnippet)
#+end_src

*** Utilities
=which-key= show me the guideline for every next hotkey of the combo.
#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :diminish
  :config
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.4))
(which-key-mode 1)
#+end_src

Sometimes I feel stupid at coding. I just duplicate a line to a line and not thinking much about optimization.
But it's quick 😁.

#+begin_src emacs-lisp :tangle yes
(defun penguin/quick-dup-line ()
  "Quickly duplicate the current line down."
  (interactive)
  (let ((beg (line-beginning-position 1))
        (end (line-beginning-position 2)))
    (if (eq last-command 'quick-copy-line)
        (kill-append (buffer-substring beg end) (< end beg))
      (kill-new (buffer-substring beg end))))
  (beginning-of-line 2)
  (yank) ;; Can be duplicated more with `C-y')
(global-set-key (kbd "C-c C-d") 'penguin/quick-dup-line)
#+end_src

A more convinient =C-a=
#+begin_src emacs-lisp :tangle yes
(global-set-key [remap move-beginning-of-line] #'penguin/beginning-of-line-dwim)
(defun penguin/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
#+end_src

Remove unnecessary keymap
#+begin_src emacs-lisp :tangle yes
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
(global-unset-key (kbd "C-h h"))
#+end_src

Setup keymap for my habit
#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-G") 'ff-find-other-file)

(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

(global-set-key [remap kill-buffer] #'kill-this-buffer)

(global-set-key (kbd "C-x 3") (lambda () (interactive)(split-window-right) (other-window 1)))
(global-set-key (kbd "C-x 2") (lambda () (interactive)(split-window-below) (other-window 1)))

(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "M-O") 'other-frame)
(global-set-key (kbd "M-N") 'next-buffer)
(global-set-key (kbd "M-P") 'previous-buffer)

(global-set-key (kbd "C-c C-b")  'windmove-left)
(global-set-key (kbd "C-c C-f") 'windmove-right)
(global-set-key (kbd "C-c C-p")    'windmove-up)
(global-set-key (kbd "C-c C-n")  'windmove-down)
#+end_src

** EWW
Working in Emacs is fun, but switching to safari or chrome to do searching stuff sometimes annoy me. As I dont like to use mouse much.
=eww= is not perfect but it can solve my current nerve right now. I'd like to learning using qutebrowser someday as a replacement.
#+begin_src emacs-lisp :tangle yes
(use-package browse-url
  :ensure nil
  :custom
  (browse-url-browser-function 'eww-browse-url)
  ;; (browse-url-browser-function 'browse-url-generic)
  ;; :config
  ;; (cond (sys/win32 (setq browse-url-generic-program qutebrowser/win32))
  ;;       (sys/macos (setq browse-url-generic-program qutebrowser/macos))
  ;;       (sys/linux (setq browse-url-generic-program "qutebrowser"))
  ;; )
)

(use-package shr
  :commands (eww
             eww-browse-url)
  :config
  (setq browse-url-browser-function 'eww-browse-url)
  (setq shr-use-fonts nil)
  (setq shr-use-colors nil)
  (setq shr-max-image-proportion 0.2)
  (setq shr-width (current-fill-column)))

(use-package shr-tag-pre-highlight
  :ensure t
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight))
  (when (version< emacs-version "26")
    (with-eval-after-load 'eww
      (advice-add 'eww-display-html :around
                  'eww-display-html--override-shr-external-rendering-functions))))
#+end_src

** LSP Mode
** Git
My setup for git is kinda complex as my habit of merging and braching seem too random. Hopefully, I will fix this sometimes ...
Now, the first part is we need to have =magit=
#+begin_src emacs-lisp :tangle yes
(use-package magit
  :bind
  ("C-x g" . magit-status)
  (:map magit-hunk-section-map
        ("RET" . magit-diff-visit-file-other-window)
        ([return] . magit-diff-visit-file-other-window))
  :custom
  (magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
  (magit-diff-highlight-hunk-body nil)
  (magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside magit-diff-highlight-hunk-region-using-face))
  (magit-popup-display-buffer-action '((display-buffer-same-window)))
  (magit-refs-show-commit-count 'all)
  (magit-section-show-child-count t)
  :config
  (remove-hook 'magit-section-highlight-hook #'magit-section-highlight))
#+end_src

A simple workflow for git need commit and message. These two will setup for us.
#+begin_src emacs-lisp :tangle yes
(use-package git-commit
  :preface
  (defun penguin/git-commit-auto-fill-everywhere ()
    (setq fill-column 72)
    (setq-local comment-auto-fill-only-comments nil))
  :hook
  (git-commit-mode . penguin/git-commit-auto-fill-everywhere)
  :custom
  (git-commit-summary-max-length 50))

(use-package git-messenger
  :bind (:map vc-prefix-map
         ("p" . git-messenger:popup-message)
         :map git-messenger-map
         ("m" . git-messenger:copy-message))
  :init (setq git-messenger:show-detail t
              git-messenger:use-magit-popup t)
  :config
  (with-no-warnings
    (with-eval-after-load 'hydra
      (defhydra git-messenger-hydra (:color blue)
        ("s" git-messenger:popup-show "show")
        ("c" git-messenger:copy-commit-id "copy hash")
        ("m" git-messenger:copy-message "copy message")
        ("," (catch 'git-messenger-loop (git-messenger:show-parent)) "go parent")
        ("q" git-messenger:popup-close "quit")))

    (defun penguin-git-mess:format-detail (vcs commit-id author message)
      (if (eq vcs 'git)
          (let ((date (git-messenger:commit-date commit-id))
                (colon (propertize ":" 'face 'font-lock-comment-face)))
            (concat
             (format "%s%s %s \n%s%s %s\n%s  %s %s \n"
                     (propertize "Commit" 'face 'font-lock-keyword-face) colon
                     (propertize (substring commit-id 0 8) 'face 'font-lock-comment-face)
                     (propertize "Author" 'face 'font-lock-keyword-face) colon
                     (propertize author 'face 'font-lock-string-face)
                     (propertize "Date" 'face 'font-lock-keyword-face) colon
                     (propertize date 'face 'font-lock-string-face))
             (propertize (make-string 38 ?─) 'face 'font-lock-comment-face)
             message
             (propertize "\nPress q to quit" 'face '(:inherit (font-lock-comment-face italic)))))
        (git-messenger:format-detail vcs commit-id author message)))

    (defun penguin-git-mess:popup-message ()
      "Popup message with `posframe', `pos-tip', `lv' or `message', and dispatch actions with `hydra'."
      (interactive)
      (let* ((vcs (git-messenger:find-vcs))
             (file (buffer-file-name (buffer-base-buffer)))
             (line (line-number-at-pos))
             (commit-info (git-messenger:commit-info-at-line vcs file line))
             (commit-id (car commit-info))
             (author (cdr commit-info))
             (msg (git-messenger:commit-message vcs commit-id))
             (popuped-message (if (git-messenger:show-detail-p commit-id)
                                  (penguin-git-mess:format-detail vcs commit-id author msg)
                                (cl-case vcs
                                  (git msg)
                                  (svn (if (string= commit-id "-")
                                           msg
                                         (git-messenger:svn-message msg)))
                                  (hg msg)))))
        (setq git-messenger:vcs vcs
              git-messenger:last-message msg
              git-messenger:last-commit-id commit-id)
        (run-hook-with-args 'git-messenger:before-popup-hook popuped-message)
        (git-messenger-hydra/body)
        (cond ((and (fboundp 'posframe-workable-p) (posframe-workable-p))
               (let ((buffer-name "*git-messenger*"))
                 (posframe-show buffer-name
                                :string popuped-message
                                :left-fringe 8
                                :right-fringe 8
                                :internal-border-color (face-foreground 'default)
                                :internal-border-width 1)
                 (unwind-protect
                     (push (read-event) unread-command-events)
                   (posframe-delete buffer-name))))
              ((and (fboundp 'pos-tip-show) (display-graphic-p))
               (pos-tip-show popuped-message))
              ((fboundp 'lv-message)
               (lv-message popuped-message)
               (unwind-protect
                   (push (read-event) unread-command-events)
                 (lv-delete-window)))
              (t (message "%s" popuped-message)))
        (run-hook-with-args 'git-messenger:after-popup-hook popuped-message)))
    (advice-add #'git-messenger:popup-close :override #'ignore)
    (advice-add #'git-messenger:popup-message :override #'penguin-git-mess:popup-message)))

#+end_src

To see revisions of a file, =git-timemachine= is needed.
#+begin_src emacs-lisp :tangle yes
(use-package git-timemachine
  :custom-face
  (git-timemachine-minibuffer-author-face ((t (:inherit success))))
  (git-timemachine-minibuffer-detail-face ((t (:inherit warning))))
  :bind (:map vc-prefix-map
         ("t" . git-timemachine)))
#+end_src

To resolve the diff conflicts, I use the =smerge-mode= and =ediff= package as my main workflow.
=ediff= is still not visualize things in the way I want, so I am still looking for an alternative way, but this works just fine right now.
#+begin_src emacs-lisp :tangle yes
(use-package smerge-mode
  :ensure nil
  :diminish
  ;; :pretty-hydra
  ;; ((:title (pretty-hydra-title "Smerge" 'octicon "diff")
  ;;   :color pink :quit-key "q")
  ;;  ("Move"
  ;;   (("n" smerge-next "next")
  ;;    ("p" smerge-prev "previous"))
  ;;   "Keep"
  ;;   (("b" smerge-keep-base "base")
  ;;    ("u" smerge-keep-upper "upper")
  ;;    ("l" smerge-keep-lower "lower")
  ;;    ("a" smerge-keep-all "all")
  ;;    ("RET" smerge-keep-current "current")
  ;;    ("C-m" smerge-keep-current "current"))
  ;;   "Diff"
  ;;   (("<" smerge-diff-base-upper "upper/base")
  ;;    ("=" smerge-diff-upper-lower "upper/lower")
  ;;    (">" smerge-diff-base-lower "upper/lower")
  ;;    ("R" smerge-refine "refine")
  ;;    ("E" smerge-ediff "ediff"))
  ;;   "Other"
  ;;   (("C" smerge-combine-with-next "combine")
  ;;    ("r" smerge-resolve "resolve")
  ;;    ("k" smerge-kill-current "kill")
  ;;    ("ZZ" (lambda ()
  ;;            (interactive)
  ;;            (save-buffer)
  ;;            (bury-buffer)
  ;;          )
  ;;     "Save and bury buffer" :exit t))
  ;;  )
  ;; )
  :bind (:map smerge-mode-map
         ("C-c m" . smerge-mode-hydra/body))
  :hook ((find-file . (lambda ()
                        (save-excursion
                          (goto-char (point-min))
                          (when (re-search-forward "^<<<<<<< " nil t)
                            (smerge-mode 1)))))
         (magit-diff-visit-file . (lambda ()
                                    (when smerge-mode
                                      (hydra-smerge/body))))))

(use-package ediff)
(defun ediff-save-window-configuration ()
  "Automatic save window configuration after ediff sessions."
  (window-configuration-to-register ?E))
(defun ediff-restore-window-configuration ()
  "Automatic restore window configuration after ediff sessions."
  (jump-to-register ?E))

(setq-default ediff-before-setup-hook (quote (ediff-save-window-configuration)))
(setq-default ediff-quit-hook (quote (ediff-cleanup-mess ediff-restore-window-configuration exit-recursive-edit)))
(setq-default ediff-suspend-hook (quote (ediff-default-suspend-function ediff-restore-window-configuration)))
(setq-default ediff-window-setup-function (quote ediff-setup-windows-plain))
(setq-default ediff-split-window-function (quote split-window-horizontally))
(setq-default ediff-highlight-all-diffs t)
(setq-default ediff-forward-word-function 'forward-char)

(use-package gitattributes-mode)
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+end_src

** Ibuffer
Changing buffer never feel better than before.
#+begin_src emacs-lisp :tangle yes
(use-package ibuffer
  :ensure nil
  :functions (all-the-icons-icon-for-file
              all-the-icons-icon-for-mode
              all-the-icons-auto-mode-match?
              all-the-icons-faicon
              my-ibuffer-find-file)
  :commands (ibuffer-find-file
             ibuffer-current-buffer)
  :bind ("C-x C-b" . ibuffer)
  :init (setq ibuffer-filter-group-name-face '(:inherit (font-lock-string-face bold)))
  :config
  (setq ibuffer-saved-filter-groups
        '(("Main"
           ("Directories" (mode . dired-mode))
           ("Org" (mode . org-mode))
           ("Programming" (or
                           (mode . c-mode)
                           (mode . conf-mode)
                           (mode . css-mode)
                           (mode . emacs-lisp-mode)
                           (mode . html-mode)
                           (mode . mhtml-mode)
                           (mode . python-mode)
                           (mode . ruby-mode)
                           (mode . scss-mode)
                           (mode . shell-script-mode)
                           (mode . yaml-mode)))
           ("Markdown" (mode . markdown-mode))
           ("Magit" (or
                     (mode . magit-blame-mode)
                     (mode . magit-cherry-mode)
                     (mode . magit-diff-mode)
                     (mode . magit-log-mode)
                     (mode . magit-process-mode)
                     (mode . magit-status-mode)))
           ("Apps" (or
                    (mode . bongo-playlist-mode)
                    (mode . mu4e-compose-mode)
                    (mode . mu4e-headers-mode)
                    (mode . mu4e-main-mode)
                    (mode . elfeed-search-mode)
                    (mode . elfeed-show-mode)
                    (mode . mu4e-view-mode)))
           ("Emacs" (or
                     (name . "^\\*Help\\*$")
                     (name . "^\\*Custom.*")
                     (name . "^\\*Org Agenda\\*$")
                     (name . "^\\*info\\*$")
                     (name . "^\\*scratch\\*$")
                     (name . "^\\*Backtrace\\*$")
                     (name . "^\\*Messages\\*$"))))))
  ;; Display buffer icons on GUI
  (when (and (display-graphic-p)
             (require 'all-the-icons nil t))
    ;; For alignment, the size of the name field should be the width of an icon
    (define-ibuffer-column icon (:name "  ")
      (let ((icon (if (and (buffer-file-name)
                           (all-the-icons-auto-mode-match?))
                      (all-the-icons-icon-for-file (file-name-nondirectory (buffer-file-name)) :v-adjust -0.05)
                    (all-the-icons-icon-for-mode major-mode :v-adjust -0.05))))
        (if (symbolp icon)
            (setq icon (all-the-icons-faicon "file-o" :face 'all-the-icons-dsilver :height 0.8 :v-adjust 0.0))
          icon)))
    (setq ibuffer-formats `((mark modified read-only ,(if emacs/>=26p 'locked "")
                                  ;; Here you may adjust by replacing :right with :center or :left
                                  ;; According to taste, if you want the icon further from the name
                                  " " (icon 2 2 :left :elide)
                                  ,(propertize " " 'display `(space :align-to 8))
                                  (name 18 18 :left :elide)
                                  " " (size 9 -1 :right)
                                  " " (mode 16 16 :left :elide) " " filename-and-process)
                            (mark " " (name 16 -1) " " filename))))
  (with-eval-after-load 'counsel
    (defun my-ibuffer-find-file ()
      (interactive)
      (let ((default-directory (let ((buf (ibuffer-current-buffer)))
                                 (if (buffer-live-p buf)
                                     (with-current-buffer buf
                                       default-directory)
                                   default-directory))))
        (counsel-find-file default-directory)))
    (advice-add #'ibuffer-find-file :override #'my-ibuffer-find-file))
  ;; Group ibuffer's list by project root
  (use-package ibuffer-projectile
    :functions all-the-icons-octicon ibuffer-do-sort-by-alphabetic
    :hook ((ibuffer . (lambda ()
                        (ibuffer-projectile-set-filter-groups)
                        (unless (eq ibuffer-sorting-mode 'alphabetic)
                          (ibuffer-do-sort-by-alphabetic)))))
    :config
    (setq ibuffer-projectile-prefix
          (if (display-graphic-p)
              (concat
               (all-the-icons-octicon "file-directory"
                                      :face ibuffer-filter-group-name-face
                                      :v-adjust -0.05
                                      :height 1.25)
               " ")
            "Project: ")))
  :hook
  (ibuffer-mode . (lambda ()
                    (ibuffer-switch-to-saved-filter-groups "Main"))))
(use-package ibuffer-vc
  :defer t
  :ensure t
  :config
  (define-ibuffer-column icon
    (:name "Icon" :inline t)
    (all-the-icons-ivy--icon-for-mode major-mode))
  :custom
  (ibuffer-formats
   '((mark modified read-only vc-status-mini " "
           (name 18 18 :left :elide)
           " "
           (size 9 -1 :right)
           " "
           (mode 16 16 :left :elide)
           " "
           filename-and-process)) "include vc status info")
  :hook
  (ibuffer . (lambda ()
               (ibuffer-vc-set-filter-groups-by-vc-root)
               (unless (eq ibuffer-sorting-mode 'alphabetic)
                 (ibuffer-do-sort-by-alphabetic)
               )
             )))
#+end_src

** Ivy
Between Helm and Ivy, I always prefer the compact UI of Ivy and it run smoother than Helm for me.
=flx= is a package support for this configuration, which should be there in the first place.
#+begin_src emacs-lisp :tangle yes
(use-package flx)
#+end_src

*Ivy* can be easily setup with these lines:
#+begin_src emacs-lisp :tangle yes
(use-package ivy
  :diminish
  :hook (after-init . ivy-mode)
  :config
  (setq ivy-display-style nil)
  (define-key ivy-minibuffer-map (kbd "RET") #'ivy-alt-done)
  (define-key ivy-minibuffer-map (kbd "<escape>") #'minibuffer-keyboard-quit)
  (setq ivy-re-builders-alist
        '((counsel-rg . ivy--regex-plus)
          (counsel-projectile-rg . ivy--regex-plus)
          (counsel-ag . ivy--regex-plus)
          (counsel-projectile-ag . ivy--regex-plus)
          (swiper . ivy--regex-plus)
          (t . ivy--regex-fuzzy)))
  (setq ivy-use-virtual-buffers t
        ivy-count-format "(%d/%d) "
        ivy-initial-inputs-alist nil))
#+end_src

=ivy-rich= is an enhancement for Ivy, which show command description and other info.
#+begin_src emacs-lisp :tangle yes
(use-package ivy-rich
  :init
  (setq ivy-rich-display-transformers-list ; max column width sum = (ivy-poframe-width - 1)
        '(ivy-switch-buffer
          (:columns
           ((ivy-rich-candidate (:width 35))
            (ivy-rich-switch-buffer-project (:width 15 :face success))
            (ivy-rich-switch-buffer-major-mode (:width 13 :face warning)))
           :predicate
           #'(lambda (cand) (get-buffer cand))
          )
          counsel-M-x
          (:columns
           ((counsel-M-x-transformer (:width 40))
            (ivy-rich-counsel-function-docstring (:width 40 :face font-lock-doc-face))
           )
          )
          counsel-describe-function
          (:columns
           ((counsel-describe-function-transformer (:width 35))
            (ivy-rich-counsel-function-docstring (:width 34 :face font-lock-doc-face))))
          counsel-describe-variable
          (:columns
           ((counsel-describe-variable-transformer (:width 35))
            (ivy-rich-counsel-variable-docstring (:width 34 :face font-lock-doc-face))))
          package-install
          (:columns
           ((ivy-rich-candidate (:width 25))
            (ivy-rich-package-version (:width 12 :face font-lock-comment-face))
            (ivy-rich-package-archive-summary (:width 7 :face font-lock-builtin-face))
            (ivy-rich-package-install-summary (:width 23 :face font-lock-doc-face))))))
  :hook (after-init . ivy-rich-mode)
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))
#+end_src

Since I found pleasure working with minibuffer, sometime it can be a new fresh to use postframe.
#+begin_src emacs-lisp :tangle yes
;; (use-package ivy-posframe
;;   :after ivy
;;   :diminish
;;   :config
;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display))
;;         ivy-posframe-height-alist '((t . 20))
;;         ivy-posframe-parameters '((internal-border-width . 10)))
;;   (setq ivy-posframe-width 100))
;; (ivy-posframe-mode 1)
#+end_src

** Hydra
Hydra is a superior package, it helps me to speed thing up when it come to hotkey for a specific task.
Though I love the way =hydra= let me draw my ascii in the minibuffer, =pretty-hydra= has done a better job at visualizing.
#+begin_src emacs-lisp :tangle yes
(use-package hydra
  :bind
  ("C-c h a" . hydra-drawibm/body)
  :custom
  (hydra-default-hint nil))

(use-package pretty-hydra
  :bind
  ("C-c h l" . hydra-lspui/body)
  ("C-c h f" . hydra-flycheck/body)
  ("C-c h p" . hydra-projectile/body)
  ("C-c h w" . hydra-window/body))
#+end_src

For =pretty-hydra=, we need a custom function for it to add the title and icon with color
#+begin_src emacs-lisp :tangle yes
(defun phydra-title (title &optional icon-type icon-name
                           &key face height v-adjust)
      "Add an icon in the hydra title."
      (let ((face (or face `(:foreground ,(face-background 'highlight))))
            (height (or height 1.0))
            (v-adjust (or v-adjust 0.0)))
        (concat
         (when (and (display-graphic-p) icon-type icon-name)
           (let ((f (intern (format "all-the-icons-%s" icon-type))))
             (when (fboundp f)
               (concat
                (apply f (list icon-name :face face :height height :v-adjust v-adjust))
                " "))))
         (propertize title 'face face))))
#+end_src

*DASHBOARD*
#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-dashboard (:title (phydra-title "Dashboard" 'material "dashboard")
                                      :color pink
                                      :quit-key "q"
                                     )
  ("Navigator"
   (("U" update-config-and-packages "update" :exit t)
    ("H" browse-homepage "homepage" :exit t)
    ("R" restore-session "recover session" :exit t)
    ("L" persp-load-state-from-file "list sessions" :exit t)
    ("S" open-custom-file "settings" :exit t))

   "Section"
   (("}" dashboard-next-section "next")
    ("{" dashboard-previous-section "previous")
    ("r" dashboard-goto-recent-files "recent files")
    ("m" dashboard-goto-bookmarks "projects")
    ("p" dashboard-goto-projects "bookmarks"))

   "Item"
   (("RET" widget-button-press "open" :exit t)
    ("<tab>" widget-forward "next")
    ("C-i" widget-forward "next")
    ("<backtab>" widget-backward "previous")
    ("C-n" next-line "next line")
    ("C-p" previous-line "previous  line"))

   "Misc"
   (("<f2>" open-dashboard "open" :exit t)
    ("g" dashboard-refresh-buffer "refresh" :exit t)
    ("Q" quit-dashboard "quit" :exit t))))
#+end_src

*IBM DRAWING*
#+begin_src emacs-lisp :tangle yes
(defcustom penguin/ibm-overwrite nil "Overwrite mode for IBM (codepage 437) box drawing.")
(defun penguin/ibm-insert (char)
  "Insert CHAR with conditional overwrite."
  (interactive)
  (when penguin/ibm-overwrite
    (kill-char 1))
  (insert char))

(defhydra hydra-drawibm (:color pink)
  "
IBM Box Chars  _r_ ─         _R_ ═         _v_ │         _V_ ║
(CodePage 437) _q_ ┌ _w_ ┬ _e_ ┐ _Q_ ╒ _W_ ╤ _E_ ╕ _t_ ╔ _y_ ╦ _u_ ╗ _T_ ╓ _Y_ ╥ _U_ ╖  _C-q_ ╭ ╮ _C-w_
               _a_ ├ _s_ ┼ _d_ ┤ _A_ ╞ _S_ ╪ _D_ ╡ _g_ ╠ _h_ ╬ _j_ ╣ _G_ ╟ _H_ ╫ _J_ ╢
               _z_ └ _x_ ┴ _c_ ┘ _Z_ ╘ _X_ ╧ _C_ ╛ _b_ ╚ _n_ ╩ _m_ ╝ _B_ ╙ _N_ ╨ _M_ ╜  _C-a_ ╰ ╯ _C-s_
_ESC_ to exit    _i_ Toggle Overwrite/Insert
"
   ("ESC" nil nil :color blue)
   ("<space>"   (search-backward "+"))
   ("S-<space>" (search-forward "+"))
   ("q" (penguin/ibm-insert "┌")) ("w" (penguin/ibm-insert "┬")) ("e" (penguin/ibm-insert "┐"))
   ("Q" (penguin/ibm-insert "╒")) ("W" (penguin/ibm-insert "╤")) ("E" (penguin/ibm-insert "╕"))
   ("t" (penguin/ibm-insert "╔")) ("y" (penguin/ibm-insert "╦")) ("u" (penguin/ibm-insert "╗"))
   ("T" (penguin/ibm-insert "╓")) ("Y" (penguin/ibm-insert "╥")) ("U" (penguin/ibm-insert "╖"))
   ("a" (penguin/ibm-insert "├")) ("s" (penguin/ibm-insert "┼")) ("d" (penguin/ibm-insert "┤"))
   ("A" (penguin/ibm-insert "╞")) ("S" (penguin/ibm-insert "╪")) ("D" (penguin/ibm-insert "╡"))
   ("g" (penguin/ibm-insert "╠")) ("h" (penguin/ibm-insert "╬")) ("j" (penguin/ibm-insert "╣"))
   ("G" (penguin/ibm-insert "╟")) ("H" (penguin/ibm-insert "╫")) ("J" (penguin/ibm-insert "╢"))
   ("z" (penguin/ibm-insert "└")) ("x" (penguin/ibm-insert "┴")) ("c" (penguin/ibm-insert "┘"))
   ("Z" (penguin/ibm-insert "╘")) ("X" (penguin/ibm-insert "╧")) ("C" (penguin/ibm-insert "╛"))
   ("b" (penguin/ibm-insert "╚")) ("n" (penguin/ibm-insert "╩")) ("m" (penguin/ibm-insert "╝"))
   ("B" (penguin/ibm-insert "╙")) ("N" (penguin/ibm-insert "╨")) ("M" (penguin/ibm-insert "╜"))
   ("r" (penguin/ibm-insert "─")) ("R" (penguin/ibm-insert "═"))
   ("v" (penguin/ibm-insert "│")) ("V" (penguin/ibm-insert "║"))
   ("C-q" (penguin/ibm-insert "╭")) ("C-w" (penguin/ibm-insert "╮"))
   ("C-a" (penguin/ibm-insert "╰")) ("C-s" (penguin/ibm-insert "╯"))
   ("i" (setq penguin/ibm-overwrite (not penguin/ibm-overwrite)) ))
#+end_src

*IVY*
TODO

*FLYCHECK*
#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-flycheck (:title (phydra-title "Flycheck" 'faicon "bug")
                                     :color pink
                                     :quit-key "q")
  ("Documentation"
   (("m" flycheck-manual "manual" :exit t)
    ("v" flycheck-verify-setup "verify setup" :exit t))
   "Errors"
   ((">" flycheck-next-error "next")
    ("<" flycheck-previous-error "previous")
    ("f" flycheck-buffer "check")
    ("l" flycheck-list-errors "list"))
   "Checker"
   (("?" flycheck-describe-checker "describe")
    ("d" flycheck-disable-checker "disable")
    ("s" flycheck-select-checker "select"))))
#+end_src

*LSP-UI*
#+begin_src emacs-lisp :tangle yes
(defun penguin/toggle-lsp-ui-doc ()
  "Toggle the LSP UI."
  (interactive)
  (if lsp-ui-doc-mode
    (progn
      (lsp-ui-doc-mode -1)
      (lsp-ui-doc--hide-frame))
    (lsp-ui-doc-mode 1)))

(pretty-hydra-define hydra-lspui (:title (phydra-title "LSP UI" 'faicon "rocket")
                                  :color amaranth
                                  :quit-key "q")
   ("Doc"
    (("d e" penguin/toggle-lsp-ui-doc "enable" :toggle t)
     ("d s" lsp-ui-doc-include-signature "signature" :toggle t)
     ("d t" (setq lsp-ui-doc-position 'top) "top" :toggle (eq lsp-ui-doc-position 'top))
     ("d b" (setq lsp-ui-doc-position 'bottom) "bottom" :toggle (eq lsp-ui-doc-position 'bottom))
     ("d p" (setq lsp-ui-doc-position 'at-point) "at point" :toggle (eq lsp-ui-doc-position 'at-point))
     ;; ("d f" (setq lsp-ui-doc-alignment 'frame) "align frame" :toggle (eq lsp-ui-doc-alignment 'frame))
     ;; ("d w" (setq lsp-ui-doc-alignment 'window) "align window" :toggle (eq lsp-ui-doc-alignment 'window)))
    "Sideline"
    (("s e" lsp-ui-sideline-enable "enable" :toggle t)
     ("s h" lsp-ui-sideline-show-hover "hover" :toggle t)
     ("s d" lsp-ui-sideline-show-diagnostics "diagnostics" :toggle t)
     ("s s" lsp-ui-sideline-show-symbol "symbol" :toggle t)
     ("s c" lsp-ui-sideline-show-code-actions "code actions" :toggle t)
     ("s i" lsp-ui-sideline-ignore-duplicate "ignore duplicate" :toggle t))))
#+end_src

*MAGIT*
TODO

*MARKDOWN*
TODO

*ORG*
TODO

*PROJECTILE*
#+begin_src emacs-lisp :tangle yes
(pretty-hydra-define hydra-projectile (:title (phydra-title "Projectile" 'faicon "rocket")
                                       :color pink
                                       :quit-key "q"
                                      )
  ("Buffers"
   (("b" counsel-projectile-switch-to-buffer "list")
    ("k" projectile-kill-buffers "kill all")
    ("S" projectile-save-project-buffers "save all"))
   "Find"
   (("d" counsel-projectile-find-dir "directory")
    ("D" projectile-dired "root")
    ("f" counsel-projectile-find-file "file")
    ("p" counsel-projectile-switch-project "project"))
   "Other"
   (("i" projectile-invalidate-cache "reset cache"))
   "Search"
   (("r" projectile-replace "replace")
    ("R" projectile-replace-regexp "regexp replace")
    ("s" counsel-rg "search"))))
#+end_src

*WINDOW*
#+begin_src emacs-lisp :tangle yes
(use-package ace-window)
(pretty-hydra-define hydra-window (:foreign-keys warn
                                   :title (phydra-title "Windows Management" 'faicon "windows")
                                   :quit-key "q"
                                   :color amaranth
                                  )
  ("Actions"
   (("TAB" other-window "switch")
    ("x" ace-delete-window "delete")
    ("m" ace-delete-other-windows "maximize")
    ("s" ace-swap-window "swap")
    ("a" ace-select-window "select"))

   "Resize"
   (("i" enlarge-window "↑ up")
    ("k" shrink-window "↓ down")
    ("j" shrink-window-horizontally "← left")
    ("l" enlarge-window-horizontally "→ right")
    ("n" balance-windows "balance")
    ("f" toggle-frame-fullscreen "toggle fullscreen"))

   "Select"
   (("p" windmove-up "↑ up")
    ("n" windmove-down "↓ down")
    ("b" windmove-left "← left")
    ("f" windmove-right "→ right"))

   "Split"
   (("h" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down)
         ) "horizontally")
    ("v" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right)
         ) "vertically"))))
#+end_src

** Paren
Automatic paren
#+begin_src emacs-lisp :tangle yes
(use-package elec-pair
  :ensure nil
  :hook (after-init . electric-pair-mode)
  :init (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit))
#+end_src

** PDF Reader
Reading is never a worthless hobby. Since Emacs is my main workspace, I would prefer to read and write on it at the same time.
The usual format for any book I can find is PDF. The =pdf-view= package is required for this job.
#+begin_src emacs-lisp :tangle yes
(when (display-graphic-p)
  (use-package pdf-view
    :ensure pdf-tools
    :diminish (pdf-view-midnight-minor-mode pdf-view-printer-minor-mode)
    :defines pdf-annot-activate-created-annotations
    :functions (penguin/pdf-view-set-midnight-colors penguin/pdf-view-set-dark-theme)
    :commands pdf-view-midnight-minor-mode
    :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
    :magic ("%PDF" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
           ("C-s" . isearch-forward))
    :init (setq pdf-annot-activate-created-annotations t)
    :config
    ;; WORKAROUND: Fix compilation errors on macOS.
    ;; @see https://github.com/politza/pdf-tools/issues/480
    (when sys/macos
      (setenv "PKG_CONFIG_PATH"
              "/usr/local/lib/pkgconfig:/usr/local/opt/libffi/lib/pkgconfig"))
    (pdf-tools-install t nil t t)

    ;; Set dark theme
    (defun penguin/pdf-view-set-midnight-colors ()
      "Set pdf-view midnight colors."
      (setq pdf-view-midnight-colors
            `(,(face-foreground 'default) . ,(face-background 'default))))

    (defun penguin/pdf-view-set-dark-theme ()
      "Set pdf-view midnight theme as color theme."
      (penguin/pdf-view-set-midnight-colors)
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (eq major-mode 'pdf-view-mode)
            (pdf-view-midnight-minor-mode (if pdf-view-midnight-minor-mode 1 -1))))))

    (penguin/pdf-view-set-midnight-colors)
    (add-hook 'after-load-theme-hook #'penguin/pdf-view-set-dark-theme)

    ;; FIXME: Support retina
    ;; @see https://emacs-china.org/t/pdf-tools-mac-retina-display/10243/
    ;; and https://github.com/politza/pdf-tools/pull/501/
    (setq pdf-view-use-scaling t
          pdf-view-use-imagemagick nil)
    (with-no-warnings
      (defun pdf-view-use-scaling-p ()
        "Return t if scaling should be used."
        (and (or (and (eq system-type 'darwin) (>= emacs-major-version 27))
                 (memq (pdf-view-image-type) '(imagemagick image-io)))
             pdf-view-use-scaling))
      (defun pdf-view-create-page (page &optional window)
        "Create an image of PAGE for display on WINDOW."
        (let* ((size (pdf-view-desired-image-size page window))
               (width (if (not (pdf-view-use-scaling-p))
                          (car size)
                        (* 2 (car size))))
               (data (pdf-cache-renderpage
                      page width width))
               (hotspots (pdf-view-apply-hotspot-functions
                          window page size)))
          (pdf-view-create-image data
            :width width
            :scale (if (pdf-view-use-scaling-p) 0.5 1)
            :map hotspots
            :pointer 'arrow))))
    ;; Recover last viewed position
    (when emacs/>=26p
      (use-package pdf-view-restore
        :hook (pdf-view-mode . pdf-view-restore-mode)
        :init (setq pdf-view-restore-filename
                    (locate-user-emacs-file ".pdf-view-restore"))))))
#+end_src

Epub format is supported, too.
#+begin_src emacs-lisp :tangle yes
;; Epub reader
(use-package nov
  :mode ("\\.epub\\'" . nov-mode)
  :functions centaur-read-mode
  :hook (nov-mode . penguin/nov-setup)
  :init
  (defun penguin/nov-setup ()
    "Setup `nov-mode' for better reading experience."
    (visual-line-mode 1)
    (centaur-read-mode)
    (face-remap-add-relative 'variable-pitch :family "Times New Roman" :height 1.5))
  :config
  ;; FIXME: errors while opening `nov' files with Unicode characters
  ;; @see https://github.com/wasamasa/nov.el/issues/63
  (with-no-warnings
    (defun penguin/nov-content-unique-identifier (content)
      "Return the the unique identifier for CONTENT."
      (when-let* ((name (nov-content-unique-identifier-name content))
                  (selector (format "package>metadata>identifier[id='%s']"
                                    (regexp-quote name)))
                  (id (car (esxml-node-children (esxml-query selector content)))))
        (intern id)))
    (advice-add #'nov-content-unique-identifier :override #'penguin/nov-content-unique-identifier))
  ;; Fix encoding issue on Windows
  (when sys/win32
    (setq process-coding-system-alist
          (cons `(,nov-unzip-program . (gbk . gbk))
                process-coding-system-alist))))
#+end_src

** Projectile
Manage file with projects is a must. Projectile is a powerful enhancement for Emacs to handle these jobs.
Mostly I will prefer ivy-counsel stuff but working with helm-projectile cause me an unknown pleasure.
#+begin_src emacs-lisp :tangle yes
(setq projectile-known-projects-file (concat pcache-dir "projectile.projects"))

(use-package projectile
  :diminish
  :bind (:map projectile-mode-map
         ("s-t" . projectile-find-file) ; `cmd-t' or `super-t'
         ("C-c p" . projectile-command-map))
  :hook (after-init . projectile-mode)
  :init
  (setq projectile-mode-line-prefix " "
        projectile-sort-order 'recentf
        projectile-use-git-grep t)
  :config
  ;; Helm support
  (projectile-mode)
  (use-package helm-projectile
    :ensure t)
  (setq projectile-completion-system 'helm)
  (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))
  (helm-projectile-on)
  (use-package wgrep
    :ensure t
    :config
    (use-package wgrep-helm :ensure t)
    (setq wgrep-auto-save-buffer t)
    (setq wgrep-change-readonly-file t))
  ;; Use the faster searcher to handle project files: ripgrep `rg'.
  (when (and (not (executable-find "fd"))
             (executable-find "rg"))
    (setq projectile-generic-command
          (let ((rg-cmd ""))
            (dolist (dir projectile-globally-ignored-directories)
              (setq rg-cmd (format "%s --glob '!%s'" rg-cmd dir)))
            (concat "rg -0 --files --color=never --hidden" rg-cmd))))
  ;; Faster searching on Windows
  (when sys/win32
    (setq projectile-indexing-method 'alien)
    (when (or (executable-find "fd") (executable-find "rg"))
      (setq projectile-indexing-method 'alien
            projectile-enable-caching nil))
    (setq projectile-git-submodule-command nil))
  ;; Support Perforce project
  (let ((val (or (getenv "P4CONFIG") ".p4config")))
    (add-to-list 'projectile-project-root-files-bottom-up val)))
#+end_src

Let's define some file that projectile should need to ignore to increase performance and the workspace seem more clean.
#+begin_src emacs-lisp :tangle yes
(setq projectile-cache-file (concat pcache-dir "projectile.cache")
      projectile-enable-caching (not noninteractive)
      projectile-indexing-method 'alien
      projectile-known-projects-file (concat pcache-dir "projectile.projects")
      projectile-require-project-root nil
      projectile-globally-ignored-files '(".DS_Store" "Icon" "TAGS")
      projectile-globally-ignored-file-suffixes '(".elc" ".pyc" ".o"))
#+end_src

** Swiper
A better search for Emacs
#+begin_src emacs-lisp :tangle yes
(use-package swiper
  :after ivy
  :preface
  (defun penguin/swiper ()
    "`swiper' with string returned by `ivy-thing-at-point' as initial input."
    (interactive)
    (swiper (ivy-thing-at-point)))
  :bind (("C-s" . penguin/swiper)
         :map swiper-map
         ("C-r" . swiper-query-replace))
  :config
  (setq swiper-action-recenter t)
  (setq swiper-goto-start-of-match t))
(use-package anzu
  :bind
  ([remap query-replace] . anzu-qxuery-replace-regexp)
  :hook
  (after-init . global-anzu-mode)
  :custom
  (anzu-cons-mode-line-p nil))
#+end_src

I also need to enhance the experience with M-x itself, helm is good for that but I find counsel and ivy better in performance.
#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :diminish
  :hook (ivy-mode . counsel-mode)
  :bind (("C-S-s" . helm-projectile-grep))
  :custom
  (counsel-rg-base-command "rg --vimgrep %s")
  :config
  (setq counsel-yank-pop-preselect-last t)
  (setq counsel-yank-pop-separator "\n—————————\n")
  (setq counsel-rg-base-command
        "rg -SHn --no-heading --color never --no-follow --hidden %s")
(use-package counsel-projectile
  :after ivy
  :config
  (setq-default ivy-initial-inputs-alist nil))
(counsel-projectile-mode 1)
#+end_src

** Terminal
This config is quite long but simple. If you are on Windows, use shell (built-in Emacs) else use vterm
#+begin_src emacs-lisp :tangle yes
(use-package shell
  :ensure nil
  :commands comint-send-string comint-simple-send comint-strip-ctrl-m
  :hook ((shell-mode . ansi-color-for-comint-mode-on)
         (shell-mode . n-shell-mode-hook)
         (comint-output-filter-functions . comint-strip-ctrl-m))
  :init
  (setq system-uses-terminfo nil)
  (defun n-shell-simple-send (proc command)
    "Various PROC COMMANDs pre-processing before sending to shell."
    (cond
     ;; Checking for clear command and execute it.
     ((string-match "^[ \t]*clear[ \t]*$" command)
      (comint-send-string proc "\n")
      (erase-buffer))
     ;; Checking for man command and execute it.
     ((string-match "^[ \t]*man[ \t]*" command)
      (comint-send-string proc "\n")
      (setq command (replace-regexp-in-string "^[ \t]*man[ \t]*" "" command))
      (setq command (replace-regexp-in-string "[ \t]+$" "" command))
      ;;(message (format "command %s command" command))
      (funcall 'man command))
     ;; Send other commands to the default handler.
     (t (comint-simple-send proc command))))
  (defun n-shell-mode-hook ()
    "Shell mode customizations."
    (local-set-key '[up] 'comint-previous-input)
    (local-set-key '[down] 'comint-next-input)
    (local-set-key '[(shift tab)] 'comint-next-matching-input-from-input)
    (setq comint-input-sender 'n-shell-simple-send)))

;; Shell Pop
(use-package shell-pop
  :bind ([f9] . shell-pop)
  :init
  (setq shell-pop-window-size 35
        shell-pop-shell-type
        (cond (sys/win32 '("eshell" "*eshell*" (lambda () (eshell))))
              ((fboundp 'vterm) '("vterm" "*vterm*" (lambda () (vterm))))
              (t '("terminal" "*terminal*" (lambda () (term shell-pop-term-shell)))))))
#+end_src

To make sure Emacs would run vterm smoothly:
#+begin_src emacs-lisp :tangle yes
;; Better term
;; @see https://github.com/akermu/emacs-libvterm#installation
(when (and module-file-suffix           ; dynamic module
           (executable-find "cmake")
           (executable-find "libtool")
           (executable-find "make"))
  (use-package vterm))
#+end_src

While using custom zsh, I prefer to get zsh highlight to make the terminal look better. This package will get ANSI & XTERM 256 color support.
#+begin_src emacs-lisp :tangle yes
(use-package xterm-color
  :defines (compilation-environment
            eshell-preoutput-filter-functions
            eshell-output-filter-functions)
  :functions (compilation-filter my-advice-compilation-filter)
  :init
  ;; For shell
  (setenv "TERM" "xterm-256color")
  (setq comint-output-filter-functions
        (remove 'ansi-color-process-output comint-output-filter-functions))
  (add-hook 'shell-mode-hook
            (lambda ()
              ;; Disable font-locking in this buffer to improve performance
              (font-lock-mode -1)
              ;; Prevent font-locking from being re-enabled in this buffer
              (make-local-variable 'font-lock-function)
              (setq font-lock-function (lambda (_) nil))
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
  ;; For eshell
  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-before-prompt-hook
              (lambda ()
                (setq xterm-color-preserve-properties t)))
    (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
    (setq eshell-output-filter-functions
          (remove 'eshell-handle-ansi-color eshell-output-filter-functions)))
  ;; For compilation buffers
  (setq compilation-environment '("TERM=xterm-256color"))
  (defun my-advice-compilation-filter (f proc string)
    (funcall f proc
             (if (eq major-mode 'rg-mode) ; compatible with `rg'
                 string
               (xterm-color-filter string))))
  (advice-add 'compilation-filter :around #'my-advice-compilation-filter)
  (advice-add 'gud-filter :around #'my-advice-compilation-filter)
  ;; For prolog inferior
  (with-eval-after-load 'prolog
    (add-hook 'prolog-inferior-mode-hook
              (lambda ()
                (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))))

#+end_src

** Utilities
MacOS path seems broken when yank a url from shell, let's fix that error
#+begin_src emacs-lisp :tangle yes
(when sys/macos
  (use-package exec-path-from-shell
    :ensure t
    :demand t
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    ;; (exec-path-from-shell-copy-env "PYTHONPATH")
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize))))
#+end_src

I config my Emacs a lot, so it is helpful if I can restart Emacs quickly.
#+begin_src emacs-lisp :tangle yes
(use-package restart-emacs
  :ensure t
  :bind* (("C-x M-c" . restart-emacs)))
#+end_src

** Weather Forecast
Like I said before, I rarely turn Emacs off so I just need this to figure out what is going on outside.
#+begin_src emacs-lisp :tangle yes
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Hochiminh")))
#+end_src

** Whitespace
Those whitespace at the end are annoying, let's get rid of them.
#+begin_src emacs-lisp :tangle yes
(use-package simple
  :ensure nil
  :hook (before-save . delete-trailing-whitespace))
#+end_src

* Language Support
** C++
** CMake
** CSS
** Elisp
** Json
** Latex
** Markdown
** Python

* User Interface

* Org Mode
